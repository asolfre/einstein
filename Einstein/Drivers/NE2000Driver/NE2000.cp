/*	File:		Template.impl.cp	Contains:	Lantern driver for the Template Wireless Card				You may incorporate this sample code into your applications without				restriction.  This sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  You are not				permitted to modify and redistribute the source as "DDK Sample Code."				If you are going to re-distribute the source, we require that you				make it clear in the source that the code was descended from				Apple-provided sample code, but that you've made changes.					Copyright:	© 1997 by Apple Computer, Inc., all rights reserved.	Obtained from NIE2.0 F1C2 build. 9/4/97*/#ifndef	__TEMPLATE_IMPL_H#include "NE2000.impl.h"#endif#ifndef	__LANTERNEVENTS_H#include "LanternEvents.h"#endif#ifndef	__DELAYTIMER_H#include "DelayTimer.h"#endif#ifndef	__REGISTERRDWR_H#include "RegisterRdWr.h"#endif#ifndef __TEMPLATEEVENT_H//#include "TemplateEvents.h"#endif#ifndef __TEMPLATEERRORS_H//#include "TemplateErrors.h"#endif////  ***** Connection to Native Einstein Code *****//extern "C" void EinsteinNetUnknown();extern "C" void EinsteinNetLog(const char*);extern "C" void EinsteinNetNew(TNE2000Sample*);extern "C" void EinsteinNetDelete(TNE2000Sample*);	extern "C" void EinsteinNetInit(TNE2000Sample*);extern "C" void EinsteinNetEnable(TNE2000Sample*);extern "C" void EinsteinNetDisable(TNE2000Sample*);extern "C" void EinsteinNetInterruptHandler(TNE2000Sample*);	extern "C" void EinsteinNetSendBuffer(TNE2000Sample*);extern "C" void EinsteinNetSendCBufferList(TNE2000Sample*);extern "C" void EinsteinNetSendPacket(TNE2000Sample*, UChar *buffer, ULong size);extern "C" NewtonErr EinsteinNetGetDeviceAddress(TNE2000Sample*, UChar *buffer, ULong size);extern "C" void EinsteinNetAddMulticastAddress(TNE2000Sample*);extern "C" void EinsteinNetDelMulticastAddress(TNE2000Sample*);extern "C" void EinsteinNetGetLinkIntegrity(TNE2000Sample*);	extern "C" void EinsteinNetSetPromiscuous(TNE2000Sample*);extern "C" void EinsteinNetGetThroughput(TNE2000Sample*);extern "C" void EinsteinNetTimerExpired(TNE2000Sample*);extern "C" void EinsteinNetInitCard(TNE2000Sample*);extern "C" void EinsteinNetSetCardInfo(TNE2000Sample*);extern "C" ULong EinsteinNetDataAvailable(TNE2000Sample*);extern "C" void EinsteinNetReceiveData(TNE2000Sample*, Ptr buffer, ULong size);////	***** Compiler flags *****//////	***** Definitions *****//////	Constants//#define kTemplateTimerEvent	'tmpl','timr',0	// Timer evevt // Macros for generate event trace code. It checks run time #ifdef kDB__pHISTORYCOLLECT	#define ADD_TRACE_EVENT(id, byte, short)		TRACE_MESSAGE(fEventTraceCollector, id, byte, short);	#define ADD_TRACE_ADDR()						TRACE_FUNCTION(fEventTraceCollector);#else	#define ADD_TRACE_EVENT(id, byte, short)	#define ADD_TRACE_ADDR()#endif////	***** Protocol class routines *****//PROTOCOL_IMPL_SOURCE_MACRO(TNE2000Sample)	// Magic stuff, do not touch.											// (For protocol class)////	TLanternDriver* TTemplateDriver::New()////		Protocol class constructor////			Allocate and set up local varibles here.////			This is called when the card is inserted. The variables fCardSocket, fCardPCMCIA and //			fDriverAPI are NOT set up right now. They are only available later in Init().////			If there is a embeded class in the protocol class, the constructor of the class //			is not executed when the protocol class is initialized. This is the limitation of //			the protocol class. It need be initialized here in the NEW(). For example://			//				PROTOCOL TTemplateDriver : ...//				{//					...//					TFoo	fFoo;			// A embeded class//					...//				}////				TTemplateDriver::New()//				{//					...//					new (&fFoo) TFoo;		// Execute the constructor//					...//				}//TLanternDriver* TNE2000Sample::New(){		fTickTime = new TTime;		EinsteinNetNew(this);	EinsteinNetLog("*===========================*\n");	EinsteinNetLog("$                           $\n");	EinsteinNetLog("$       Create Driver       $\n");	EinsteinNetLog("$                           $\n");	EinsteinNetLog("*===========================*\n");	return this;													// Always return this}////	TTemplateDriver::Delete()////		Protocol class destructor////			Clean up and free all momory allocations//			This is called when the card is removed.//void TNE2000Sample::Delete(){	EinsteinNetDelete(this);		delete fTickTime;	fTickTime = nil;}////	***** Lantern task service routines *****//////	NewtonErr TTemplateDriver::Init()////		Driver initialization////			This is called when the card has been inserted in the system.//			It should intialize the driver and set up the card here.//NewtonErr TNE2000Sample::Init(){	NewtonErr err = noErr;    EinsteinNetInit(this);		//	Add Lantern request functions	fDriverAPI->AddEventHandler(kLanternSendBuffer, (DriverProcPtr) &TNE2000Sample::SendBuffer);	fDriverAPI->AddEventHandler(kLanternSendCBufferList, (DriverProcPtr) &TNE2000Sample::SendCBufferList);	fDriverAPI->AddEventHandler(kLanternGetDeviceAddress, (DriverProcPtr) &TNE2000Sample::GetDeviceAddress);	fDriverAPI->AddEventHandler(kLanternAddMulticastAddress, (DriverProcPtr) &TNE2000Sample::AddMulticastAddress);	fDriverAPI->AddEventHandler(kLanternDelMulticastAddress, (DriverProcPtr) &TNE2000Sample::DelMulticastAddress);	fDriverAPI->AddEventHandler(kLanternGetLinkIntegrity, (DriverProcPtr) &TNE2000Sample::GetLinkIntegrity);		// Add Optional handlers	fDriverAPI->AddEventHandler(kLanternSetPromiscuous, (DriverProcPtr) &TNE2000Sample::SetPromiscuous);	fDriverAPI->AddEventHandler(kLanternGetThroughput, (DriverProcPtr) &TNE2000Sample::GetThroughput);		// Add private timer services handler	fDriverAPI->AddEventHandler(kTemplateTimerEvent, (DriverProcPtr) &TNE2000Sample::TimerExpired);	fTimerPosted = false;	return err;}////	NewtonErr TTemplateDriver::Enable()////		Enable: set up card and start Rx////			This method is called whenever the services of the card are required by clients.//			It is called once when the first client requires services. Subsequent clients//			do not cause this call to be repeated. Clients of an Ethernet card can be AppleTalk,//			TCP/IP or a protoLanternClient from NewtonScript.////			*** NOTE ***////				It is imperative that you do not access the card memory unless//				the driver is enabled.  If you access card memory at any other//				time the Lantern subsystem may be halted.//NewtonErr TNE2000Sample::Enable(){	NewtonErr err = noErr;	Boolean powerOn;	// Turn on card power	fDriverAPI->PowerOn(&powerOn);									// Turn on card power	fStatus |= kStatusCardPowerOn;									// Remember it for destructor to power off	EinsteinNetEnable(this);	if (!fTimerPosted)	{		// This posts the event to our own task so we get the event		fTimerPosted = true;		*fTickTime = GetGlobalTime() + TTime(kTimerTime, kMilliseconds);		fDriverAPI->PostLocalEvent(fTickTime, kTemplateTimerEvent);	}		return err;}////	NewtonErr TTemplateDriver::Disable()////		Disable: stop Rx and Tx operations////			This method is called when there no more clients that require the services of the card,//			or it has been determined that the card is no longer available in the system.//NewtonErr TNE2000Sample::Disable(){	NewtonErr err = noErr;	fDriverAPI->PowerOff();											// Turn off card power and remember it	fStatus &= ~kStatusCardPowerOn;	EinsteinNetDisable(this);	return err;}////	ULong TTemplateDriver::TimerExpired()////		This is a general purpose timer routine.  You may implement as many different timers//		as needed for your particular implementation by adding different events and eventhandlers//		for each timer.////		The three parts to defining this as a timer is to////			1. Add an eventhandler to handle your specifically defined event//			2. Call PostLocalEvent with a delay for the time to send the event//			3. Implement the timer event handler method.////		This timer periodically checks the link integrity (although for this chipset it cannot//		be detected so it just returns true).////			You can send this event out to clients that the link status has changed. //			This is not a necessary event but should be implemented if the link integrity //			can be detected by interrupt (or by timed event polling). If you detect //			the link is bad (packet errors say) you may send this event but should keep //			accepting further requests.////void TNE2000Sample::TimerExpired(void){	if (fStatus & kStatusCardPowerOn)	{		EinsteinNetTimerExpired(this);		// Should grab the link Integrity and post it here		//Boolean linkIntegrity = GetLinkIntegrity();		//if (linkIntegrity != fLinkIntegrity)		//	fDriverAPI->PostEvent(kLanternLinkIntegrity, (ULong) (fLinkIntegrity = linkIntegrity));				// This posts the event to our own task so we get the event		fTimerPosted = true;		*fTickTime = *fTickTime + TTime(kTimerTime, kMilliseconds);		fDriverAPI->PostLocalEvent(fTickTime, kTemplateTimerEvent);	}	else	{		// else timer services are cancelled.		fTimerPosted = false;	}}////	NewtonErr TTemplateDriver::InterruptHandler()////		Interrupt handler (called from task level, not in interrupt level)////			This method is called after an interrupt line on the card is asserted.//			This method is dispatched as a priority event from the system interrupt handler//			and as such is not 'true' interrupt code, consequently it does not have to execute as //			time critical or out-of-state code. However, as a priority event, it is dispatched//			before any other pending RPCs waiting on the driver. The current minimum time between//			a card interrupt and this method executing is apTemplateately 50 mSecs but could be longer//			depending on OS loading.////			There is a fundamental assumption that a Lantern device is capable of buffering inbound //			data for at least as long as required for the interrupt event to be dispatched. For high //			bit rate cards (wired Ethernet) on a busy network (e.g. large AppleTalk nets) this may//			cause loss of packets. As a data link layer, lost packets are allowable, however some//			protocols, especially AppleTalk on the Newton, may be fragile to loosing certain packets.//void TNE2000Sample::InterruptHandler(){	NewtonErr err = noErr;	EinsteinNetInterruptHandler(this);    // packetSize is the size of the Ethernet package *excluding* the CRC checksum    ULong packetSize = EinsteinNetDataAvailable(this);    if (packetSize) {        ULong bufferSize = (packetSize + 3) & 0xfffffffc; // word align for historical reasons        Ptr packetBuffer = fDriverAPI->NewPacketPtr(bufferSize + 4);        EinsteinNetReceiveData(this, packetBuffer, packetSize);        fDriverAPI->RxReady(packetBuffer, packetSize);    }		fDriverAPI->InterruptDone();									// This call is optional (here it's not really needed)}////	***** Lantern client service routines *****//////	void	  TTemplateDriver::SendBuffer(Ptr thePacket, Size packetSize)//	void	  TTemplateDriver::SendCBufferList(CBufferList* thePacket)////		Send a packet in the buffer ptr or the CBufferList////			These events is sent to a driver when Lantern needs data to be sent. The//			driver should send data asynchronously. The driver should buffer data //			to be sent as it may receive more data to send.//void TNE2000Sample::SendBuffer(Ptr thePacket, Size packetSize){	NewtonErr err = noErr;	EinsteinNetSendBuffer(this);		EinsteinNetSendPacket(this, (UChar*)thePacket, packetSize);	fDriverAPI->PostReply(err);}void TNE2000Sample::SendCBufferList(CBufferList* thePacket){	NewtonErr err = noErr;	EinsteinNetSendCBufferList(this);		Size packetSize = thePacket->GetSize();	thePacket->ResetMark();	UChar *tmpBuffer = (UChar*)malloc(packetSize);	thePacket->Getn(tmpBuffer, packetSize);	EinsteinNetSendPacket(this, tmpBuffer, packetSize);	free(tmpBuffer);	fDriverAPI->PostReply(err);}////	void TTemplateDriver::GetDeviceAddress()////		Return the 6-byte device Ethernet hardware address//void TNE2000Sample::GetDeviceAddress(UByte* addr, Size size){	NewtonErr err = noErr;		err = EinsteinNetGetDeviceAddress(this, addr, size);		fDriverAPI->PostReply(err);}////	void TTemplateDriver::AddMulticastAddress(UChar* addr)////		Add a multicast address//void TNE2000Sample::AddMulticastAddress(UChar* addr){	NewtonErr err = noErr;		EinsteinNetAddMulticastAddress(this);	fDriverAPI->PostReply(err);										// Reply}////	void TTemplateDriver::DelMulticastAddress(UChar* addr)////		Delete a multicast address//void TNE2000Sample::DelMulticastAddress(UChar* addr){	NewtonErr err = noErr;		EinsteinNetDelMulticastAddress(this);	fDriverAPI->PostReply(err);										// Reply}////	void TTemplateDriver::GetLinkIntegrity()////		Get the link integrity flag//void TNE2000Sample::GetLinkIntegrity(){	NewtonErr err = noErr;	ULong linkIntegrity = true;	EinsteinNetGetLinkIntegrity(this);		fDriverAPI->PostReply(err, 1, linkIntegrity);				// Reply}void TNE2000Sample::SetPromiscuous(ULong promiscuous){	NewtonErr err = noErr;	EinsteinNetSetPromiscuous(this);	err = eLANTERN_DriverUnhandledEvent;	fDriverAPI->PostReply(err);				// Reply}void TNE2000Sample::GetThroughput(void){	NewtonErr err = noErr;	EinsteinNetGetThroughput(this);	err = eLANTERN_DriverUnhandledEvent;	fDriverAPI->PostReply(err);				// Reply}////	***** Card routines *****//#ifdef forDebug////	void TTemplateDriver::DumpBuffer(UChar* buffer, ULong size, ULong startingAddr)////		Dump buffer data//void TNE2000Sample::DumpBuffer(UChar* buffer, ULong size, ULong startingAddr){	for (ULong i = 0; i < ((size+15) / 16); i++)	{		if ((i & 7) == 0)			printf("\n");		printf("%04X.%04X:", startingAddr + i*16, i*16);		for (ULong j = 0; j < 16; j++)		{			if ((j&3) == 0) printf(" ");			printf("%02X ", buffer[j]);			if (j == 7) printf("-");		}		printf("  ");		for (j = 0; j < 16; j++)		{			if ((j&7) == 0) printf(" ");			char ch = buffer[j];			if ((ch < ' ') || (127 < ch))				ch = '.';			printf("%c", ch);		}		printf("\n");		buffer += 16;	}	printf("\n");}#endif//==========================================================================================//==========================================================================================#if 0/*	File:		NE2000.cp	Contains:	Lantern driver sample code for PCMCIA NE2000 Ethernet card				You may incorporate this sample code into your applications without				restriction.  This sample code has been provided "AS IS" and the				responsibility for its operation is 100% yours.  You are not				permitted to modify and redistribute the source as "DDK Sample Code."				If you are going to re-distribute the source, we require that you				make it clear in the source that the code was descended from				Apple-provided sample code, but that you've made changes.					Copyright:	© 1997 by Newton, Inc., all rights reserved.	Obtained from NIE2.0 F1C2 build. 9/4/97*/#ifndef	__NE2000_IMPL_H#include "NE2000.impl.h"#endif#ifndef	__NE2000_H#include "NE2000.h"#endif#ifndef	__LANTERNEVENTS_H#include "LanternEvents.h"#endif#ifndef	__DELAYTIMER_H#include "DelayTimer.h"#endif#ifndef	__REGISTERRDWR_H#include "RegisterRdWr.h"#endif#ifndef __BUFFERLIST_H#include "BufferList.h"#endif#ifndef __LISTITERATOR_H#include "ListIterator.h"#endif#ifndef __LIST_H#include "List.h"#endif#ifndef	__COMMERRORS_H#include "CommErrors.h"#endif#ifndef __NEW_H#include <New.h>#endif////	***** Compiler flags *****//// The NE2000 sample driver initially does 8-bit access to read Ethernet ID block from the card// Later it changes to 8- or 16- access according the info from the Ethernet ID block.// Since the Newton system update/patch for a PCMCIA API fix has not been released yet,// the Do16BitXferOnly is set to 1 here to do 16-bit only access.#define Do16BitXferOnly						1						 // ¥¥¥¥ÊDo 16-bit only before patch for PCMCIA API fix is released// For the 8-bit only IO card or testing 8-bit xfer, set Do8BitXferOnly to 1#define Do8BitXferOnly						0						 // ¥¥¥¥ÊForce to 8-bit IO access// For event tracing#define	TestEventTracing					(1 && defined(forDebug)) // Turn on event tracing#if TestEventTracing#define	kDB__pHISTORYCOLLECT	1#include "historyCollectorMACRO.h"#endif////	***** Definitions *****//////	Constants//// Tx/Rx buffers are allocated at run time by 3/8 ratio//		16 KB buffer: Tx 6 KB, 24 pages, 1536*4 bytes;	Rx 10 KB, 40 pages, 1536*6.6 bytes;//		 8 KB buffer: Tx 3 KB, 12 pages, 1536*2 bytes;	Rx  5 KB, 20 pages, 1536*3.3 bytes;const UChar kNICTxBufferRatioNumerator		=	3;					// Tx buffer ratio 3/8 of total bufferconst UChar kNICTxBufferRatioDenominator	=	8;const UChar kNICTxPageStart					=	0x40;				// Default Tx buffer page start (12 pages, 3 KB, 1536*2 bytes)const UChar kNICRxPageStart					=	0x4C;				// Default Rx buffer page start for 8K buffer (20 pages, 5 KB)const UChar kNICRxPageStop					=	0x60;				// Default Rx buffer page stop for 8K bufferconst UChar kDefaultCmdDisableValue			=	kNICCommandRemoteDMAAbort | kNICCommandStop;const UChar kDefaultCmdEnableValue			=	kNICCommandRemoteDMAAbort | kNICCommandStart;const UChar kDefaultCmdPage0DisableValue	=	kDefaultCmdDisableValue | kNICCommandPageSelect0;const UChar kDefaultCmdPage1DisableValue	=	kDefaultCmdDisableValue | kNICCommandPageSelect1;const UChar kDefaultCmdPage0EnableValue		=	kDefaultCmdEnableValue | kNICCommandPageSelect0;const UChar kDefaultCmdPage1EnableValue		=	kDefaultCmdEnableValue | kNICCommandPageSelect1;const UChar kDefaultRxConfigValue			=	kNICReceiveConfigBroadcastOK | kNICReceiveConfigMulticastOK;const UChar kDefaultTxConfigValue			=	kNICTransConfigAutoTransmitOff;const UChar kDefaultDataConfigValue			=	kNICDataConfigFIFOThreshold8B;const UChar kDefaultRxInterruptMask			=	kNICInterruptPacketReceived | kNICInterruptOverwriteWarning;const UChar kDefaultTxInterruptMask			=	kNICInterruptPacketTransmitted | kNICInterruptTransmitError;const ULong kWaitForIdleTimeOut				=	400 * kMicroseconds; // Time to wait for NIC idle after resetconst ULong kWaitForDMADoneTimeOut			=	100 * kMicroseconds; // Time to wait for remote DMA done. Typical 10-40 us#define kNE2000TimerEvent					'ne2k','timr',0			// Timer evevt #define	kNE2000LinkIntegrityCheckTime		500						// Time in Milliseconds to check the link integrity////	Event tracing definitions////		NOTE: Event trace records real time events for the debugger.//			  This feature depends on which debugger is used and may not be available to developers//enum kNE2000EventTraceCodes											// Event trace codes{	kNE2000EventCommandReg					=	1,	kNE2000EventIntRxTxStatusReg,	kNE2000EventRxNxtCur,	kNE2000EventRxPagesPktNextBnry,	kNE2000EventInit,	kNE2000EventEnable,	kNE2000EventDisable,	kNE2000EventTimerExpired,	kNE2000EventInterruptHandler,	kNE2000EventSendBuffer,	kNE2000EventSendCBufferList,	kNE2000EventGetDeviceAddress,	kNE2000EventAddMulticastAddress,	kNE2000EventDelMulticastAddress,	kNE2000EventGetLinkIntegrity,	kNE2000EventSetPromiscuous,	kNE2000EventGetThroughput,	kNE2000EventNICInit,	kNE2000EventBufferSize,	kNE2000EventBufferPages,	kNE2000EventStartRx,	kNE2000EventStartTx,	kNE2000EventStopRxTx,	kNE2000EventRxOk,	kNE2000EventRxError,	kNE2000EventRxBufferOverflow,	kNE2000EventRxBadPageOrSize,	kNE2000EventRxNoBufferAvail,	kNE2000EventTxOk,	kNE2000EventTxError,	kNE2000EventRxPacketXfer,	kNE2000EventTxDone,	kNE2000EventRemoteDMAXferRead,	kNE2000EventRemoteDMAXferWrite,	kNE2000EventRemoteDMAXferData,	kNE2000EventWaitForStatus,	kNE2000EventWaitForIdle,	kNE2000EventTxQueueInit,	kNE2000EventTxQueueAddPacket,	kNE2000EventTxQueueRemovePacket,	kNE2000EventTxQueueGetPacket,	kNE2000EventTxQueueOverflow,	kNE2000EventTxQueueFirstPacket,	kNE2000EventTxQueueLastPacket,	kNE2000EventDriverAPIEnter,	kNE2000EventDriverAPIExit,	kNE2000EventDescSize};// Macros for generate event trace code. It checks run time #if TestEventTracing	#define ADD_TRACE_EVENT(id, byte, short)		TRACE_MESSAGE(fEventTraceCollector, id, byte, short);	#define ADD_TRACE_ADDR()						TRACE_FUNCTION(fEventTraceCollector);	#define ADD_TRACE_EVENT_TxQ(id, byte, short)	TRACE_MESSAGE(fNE2000Sample->fEventTraceCollector, id, byte, short);	#define ADD_TRACE_ADDR_TxQ()					TRACE_FUNCTION(fNE2000Sample->fEventTraceCollector);#else	#define ADD_TRACE_EVENT(id, byte, short)	#define ADD_TRACE_ADDR()	#define ADD_TRACE_EVENT_TxQ(id, byte, short)	#define ADD_TRACE_ADDR_TxQ()#endif#if defined(forDebug)	#define	DUMP_Tx_QUEUE(msg, p0)	\		if (fNE2000Sample->fDebugControls & kDebugControlPrintTxQueue) DumpTxQueueinfo(msg, p0);#else	#define DUMP_Tx_QUEUE(msg, p0)#endif////  ***** Connection to Native Einstein Code *****//extern "C" void EinsteinNetUnknown();extern "C" void EinsteinNetLog(const char*);extern "C" void EinsteinNetNew(TNE2000Sample*);extern "C" void EinsteinNetDelete(TNE2000Sample*);	extern "C" void EinsteinNetInit(TNE2000Sample*);extern "C" void EinsteinNetEnable(TNE2000Sample*);extern "C" void EinsteinNetDisable(TNE2000Sample*);extern "C" void EinsteinNetInterruptHandler(TNE2000Sample*);	extern "C" void EinsteinNetSendBuffer(TNE2000Sample*);extern "C" void EinsteinNetSendCBufferList(TNE2000Sample*);extern "C" void EinsteinNetSendPacket(TNE2000Sample*, UChar *buffer, ULong size);extern "C" NewtonErr EinsteinNetGetDeviceAddress(TNE2000Sample*, UChar *buffer, ULong size);extern "C" void EinsteinNetAddMulticastAddress(TNE2000Sample*);extern "C" void EinsteinNetDelMulticastAddress(TNE2000Sample*);extern "C" void EinsteinNetGetLinkIntegrity(TNE2000Sample*);	extern "C" void EinsteinNetSetPromiscuous(TNE2000Sample*);extern "C" void EinsteinNetGetThroughput(TNE2000Sample*);extern "C" void EinsteinNetTimerExpired(TNE2000Sample*);extern "C" void EinsteinNetInitCard(TNE2000Sample*);extern "C" void EinsteinNetSetCardInfo(TNE2000Sample*);extern "C" ULong EinsteinNetDataAvailable(TNE2000Sample*);extern "C" void EinsteinNetReceiveData(TNE2000Sample*, Ptr buffer, ULong size);////	***** Protocol class routines *****//PROTOCOL_IMPL_SOURCE_MACRO(TNE2000Sample)							// Magic stuff, do not touch. (For protocol class)////	TLanternDriver* TNE2000Sample::New()////		Protocol class constructor////			Allocate and set up local varibles here.////			This is called when the card is inserted. The variables fCardSocket, fCardPCMCIA and //			fDriverAPI are NOT set up right now. They are only available later in Init().////			If there is a embeded class in the protocol class, the constructor of the class //			is not executed when the protocol class is initialized. This is the limitation of //			the protocol class. It need be initialized here in the NEW(). For example://			//				PROTOCOL TNE2000Sample : ...//				{//					...//					TFoo	fFoo;			// A embeded class//					...//				}////				TNE2000Sample::New()//				{//					...//					new (&fFoo) TFoo;		// Execute the constructor//					...//				}//TLanternDriver* TNE2000Sample::New(){  	EinsteinNetNew(this);	EinsteinNetLog("*** Test the Log function!");  	// Init status	fStatus = kStatusNoStatus;	fMulticastAddrDataBase = nil;	fTxPacketQueue = nil;		new (&fTickTime) TTime;											// Execute the constructor	return this;													// Always return this}////	TNE2000Sample::Delete()////		Protocol class destructor////			Clean up and free all momory allocations//			This is called when the card is removed.//void TNE2000Sample::Delete(){  	EinsteinNetDelete(this);		// NOTE: PowerOn() and PowerOff() have to be balanced. So turn power off if we turn it on	if (fStatus & kStatusCardPowerOn)								// Turn off card power if if was turned on by us		fDriverAPI->PowerOff();	delete fMulticastAddrDataBase;									// Delete multicast data base	delete fTxPacketQueue;											// Delete Tx queue	// fTickTime.~TTime();											// TTime has no destructor }////	***** Lantern task service routines *****//////	NewtonErr TNE2000Sample::Init()////		Driver initialization////			This is called when the card has been inserted in the system.//			It should intialize the driver and set up the card here.//NewtonErr TNE2000Sample::Init(){  	EinsteinNetInit(this);	NewtonErr err = noErr;	ULong i;	// Hard-coded numbers	fCardConfigBaseAddr = fCardSocket->AttributeMemBaseAddr() + 0x3F8;	// Hard-coded configuration reg base addr	fCardConfigNumber = 0x20;										// Hard-coded configuration number	fNICBaseAddr = fCardSocket->IOBaseAddr() + 0x300;				// Hard-coded NIC offset	// Init variables		fRxPageStart = kNICRxPageStart;									// Set up default DMA pages	fRxPageStop = kNICRxPageStop;	fRxNextPacketPage = 0;											// Init misc variables	fInterruptMask = 0;	fLinkIntegrity = false;	//for (i = 0; i < kPacketAddrSize; i++)							// Init Ethernet address	//	fEthernetAddr[i] = 0;  	err = EinsteinNetGetDeviceAddress(this, fEthernetAddr, 6);	if (err) goto exit;	for (i = 0; i < kNICMulticastAddrSize; i++)						// Init multicast address	{		fMulticastAddrFilterBits[i] = 0;	}		fMulticastAddrDataBase = new TMulticastAddrDataBase;			// Set up multicast data base	XREQUIRE_ACTION(fMulticastAddrDataBase, exit, err = kError_No_Memory;);	// Init card		//err = InitCard();												// The card power has been turned on in Init()	if (err) goto exit;		// Set up card info: Get Ethernet addr from card, check card buffer, etc	//err = SetCardInfo();	if (err) goto exit;	//	Add Lantern request functions	fDriverAPI->AddEventHandler(kLanternSendBuffer, (DriverProcPtr) &TNE2000Sample::SendBuffer);	fDriverAPI->AddEventHandler(kLanternSendCBufferList, (DriverProcPtr) &TNE2000Sample::SendCBufferList);	fDriverAPI->AddEventHandler(kLanternGetDeviceAddress, (DriverProcPtr) &TNE2000Sample::GetDeviceAddress);	fDriverAPI->AddEventHandler(kLanternAddMulticastAddress, (DriverProcPtr) &TNE2000Sample::AddMulticastAddress);	fDriverAPI->AddEventHandler(kLanternDelMulticastAddress, (DriverProcPtr) &TNE2000Sample::DelMulticastAddress);	fDriverAPI->AddEventHandler(kLanternGetLinkIntegrity, (DriverProcPtr) &TNE2000Sample::GetLinkIntegrity);	fDriverAPI->AddEventHandler(kLanternSetPromiscuous, (DriverProcPtr) &TNE2000Sample::SetPromiscuous);	fDriverAPI->AddEventHandler(kLanternGetThroughput, (DriverProcPtr) &TNE2000Sample::GetThroughput);		// Add private timer services handler	fDriverAPI->AddEventHandler(kNE2000TimerEvent, (DriverProcPtr) &TNE2000Sample::TimerExpired);	fTimerPosted = false;exit:	return err;}////	NewtonErr TNE2000Sample::Enable()////		Enable: set up card and start Rx////			This method is called whenever the services of the card are required by clients.//			It is called once when the first client requires services. Subsequent clients//			do not cause this call to be repeated. Clients of an Ethernet card can be AppleTalk,//			TCP/IP or a protoLanternClient from NewtonScript.//NewtonErr TNE2000Sample::Enable(){  	EinsteinNetEnable(this);	NewtonErr err = noErr;	// Turn on card power	Boolean powerOn;	fDriverAPI->PowerOn(&powerOn);									// Turn on card power	fStatus |= kStatusCardPowerOn;									// Remember it for destructor to power off	// The powerOn indicates the power was just turned on in PowerOn() or not.	// If the powerOn is true, we need to initialize the card after the power on	// ¥¥¥¥ For some reason, the powerOn doesn't work well. So we always initialize card until the problem is fixed	//	if (powerOn)													// Check power was just just turned on in PowerOn()	{		//err = InitCard();											//  then initialize card		if (err) goto exit;	}	// Make sure there isn't already an outstanding timer to avoid starting two timers up.	if (!fTimerPosted)	{		// This posts the event to our own task so we get the event		fTimerPosted = true;		fTickTime = GetGlobalTime() + TTime(kNE2000LinkIntegrityCheckTime, kMilliseconds);		fDriverAPI->PostLocalEvent(&fTickTime, kNE2000TimerEvent);	}	// Enable and start Rx	fStatus |= kStatusEnabled;										// Enabled	//err = NICStartRx();												// Start Rxexit:		return err;}////	NewtonErr TNE2000Sample::Disable()////		Disable: stop Rx and Tx operations////			This method is called when there no more clients that require the services of the card,//			or it has been determined that the card is no longer available in the system.//NewtonErr TNE2000Sample::Disable(){  	EinsteinNetDisable(this);	NewtonErr err = noErr;	//err = NICStopRxTx();											// Stop Rx, Tx and remote DMA	fStatus &= ~kStatusEnabled;										// Enabled (countine even error)	fDriverAPI->PowerOff();											// Turn off card power and remember it	fStatus &= ~kStatusCardPowerOn;		return err;}////	ULong TNE2000Sample::TimerExpired()////		This is a general purpose timer routine.  You may implement as many different timers//		as needed for your particular implementation by adding different events and eventhandlers//		for each timer.////		The three parts to defining this as a timer is to////			1. Add an eventhandler to handle your specifically defined event//			2. Call PostLocalEvent with a delay for the time to send the event//			3. Implement the timer event handler method.////		This timer periodically checks the link integrity (although for this chipset it cannot//		be detected so it just returns true).////			You can send this event out to clients that the link status has changed. //			This is not a necessary event but should be implemented if the link integrity //			can be detected by interrupt (or by timed event polling). If you detect //			the link is bad (packet errors say) you may send this event but should keep //			accepting further requests.////void TNE2000Sample::TimerExpired(void){  	EinsteinNetTimerExpired(this);	if (fStatus & kStatusCardPowerOn)	{	/*		Boolean linkIntegrity = NICGetLinkIntegrity();				// Get link status		if (linkIntegrity != fLinkIntegrity)			fDriverAPI->PostEvent(kLanternLinkIntegrity, (ULong) (fLinkIntegrity = linkIntegrity));		*/				// This posts the event to our own task so we get the event		fTimerPosted = true;		fTickTime = fTickTime + TTime(kNE2000LinkIntegrityCheckTime, kMilliseconds);		fDriverAPI->PostLocalEvent(&fTickTime, kNE2000TimerEvent);	}	else	{		// else timer services are cancelled.		fTimerPosted = false;	}}////	NewtonErr TNE2000Sample::InterruptHandler()////		Interrupt handler (called from task level, not in interrupt level)////			This method is called after an interrupt line on the card is asserted.//			This method is dispatched as a priority event from the system interrupt handler//			and as such is not 'true' interrupt code, consequently it does not have to execute as //			time critical or out-of-state code. However, as a priority event, it is dispatched//			before any other pending RPCs waiting on the driver. The current minimum time between//			a card interrupt and this method executing is approximately 50 mSecs but could be longer//			depending on OS loading.////			There is a fundamental assumption that a Lantern device is capable of buffering inbound //			data for at least as long as required for the interrupt event to be dispatched. For high //			bit rate cards (wired Ethernet) on a busy network (e.g. large AppleTalk nets) this may//			cause loss of packets. As a data link layer, lost packets are allowable, however some//			protocols, especially AppleTalk on the Newton, may be fragile to loosing certain packets.//void TNE2000Sample::InterruptHandler(){  	EinsteinNetInterruptHandler(this);	NewtonErr err = noErr;	for (;;) { // we must not do this in a loop. NewtonOS can not receive more than one package at a time		ULong packetSize = EinsteinNetDataAvailable(this);		if (packetSize==0)			break;		ULong bufferSize = (packetSize + 3) & 0xfffffffc;		Ptr	packetBuffer = fDriverAPI->NewPacketPtr(bufferSize);		EinsteinNetReceiveData(this, packetBuffer, packetSize);		fDriverAPI->RxReady(packetBuffer, packetSize - kPacketCRCSize); // The CRC is not sent!	}	//err = NICCheckStatus();											// Check status and dispatch it		fDriverAPI->InterruptDone();									// This call is optional (here it's not really needed)}////	***** Lantern client service routines *****//////	void	  TNE2000Sample::SendBuffer(Ptr thePacket, Size packetSize)//	void	  TNE2000Sample::SendCBufferList(CBufferList* thePacket)//	NewtonErr TNE2000Sample::SendPacket(UChar* buffer, CBufferList* cBufferList, ULong packetSize)////		Send a packet in the buffer ptr or the CBufferList////			These events is sent to a driver when Lantern needs data to be sent. The//			driver should send data asynchronously. The driver should buffer data //			to be sent as it may receive more data to send.//void TNE2000Sample::SendBuffer(Ptr thePacket, Size packetSize){  	EinsteinNetSendBuffer(this);	SendPacket((UChar*)thePacket, nil, packetSize);}void TNE2000Sample::SendCBufferList(CBufferList* thePacket){  	EinsteinNetSendCBufferList(this);	SendPacket(nil, thePacket, thePacket->GetSize());}NewtonErr TNE2000Sample::SendPacket(UChar* buffer, CBufferList* cBufferList, ULong packetSize)	// Send packet{	NewtonErr err = noErr;		ULong srcAddr = 0;	if (cBufferList)	{		cBufferList->ResetMark();							// Reset buffer marker		UChar *tmpBuffer = new UChar[packetSize];		cBufferList->Getn(tmpBuffer, packetSize);	  	EinsteinNetSendPacket(this, tmpBuffer, packetSize);		delete[] tmpBuffer;	} else {	  	EinsteinNetSendPacket(this, buffer, packetSize);	}	fDriverAPI->PostReply(err);										// Reply	return err;}////	void TNE2000Sample::GetDeviceAddress()////		Return the 6-byte device Ethernet hardware address//void TNE2000Sample::GetDeviceAddress(UByte* addr, Size size){	// Fill with some random default	/*	addr[0] = 0x52; // bit 0 must be clear, bit 1 decides if this is a local MAC	addr[1] = 0x54;	addr[2] = 0xde;	addr[3] = 0xad;	addr[4] = 0xbe;	addr[5] = 0xef;		// Ask Einstein for the correct MAC address (eLANTERN_DriverValueRangeError if size != 6)  	NewtonErr err = EinsteinNetGetDeviceAddress(this, addr, size);	*/		NewtonErr err = noErr;	memcpy(addr, fEthernetAddr, 6);		fDriverAPI->PostReply(err);	return;}////	void TNE2000Sample::AddMulticastAddress(UChar* addr)////		Add a multicast address////		NOTE: The driver is required to maintain a counter for each multicast address.//		This allows the same multicast address to be shared by different clients.//		The multicast address will be deleted from the card when the counter is//		decreased to 0 by DelMulticastAddress().//void TNE2000Sample::AddMulticastAddress(UChar* addr){  	EinsteinNetAddMulticastAddress(this);	NewtonErr err = noErr; //NICAddDeleteMulticastAddr(addr, true);			// Add it	fDriverAPI->PostReply(err);										// Reply}////	void TNE2000Sample::DelMulticastAddress(UChar* addr)////		Delete a multicast address//void TNE2000Sample::DelMulticastAddress(UChar* addr){  	EinsteinNetDelMulticastAddress(this);	NewtonErr err = noErr; //NICAddDeleteMulticastAddr(addr, false);			// Delete it	fDriverAPI->PostReply(err);										// Reply	ADD_TRACE_EVENT(kNE2000EventDelMulticastAddress, 9, err);}////	void TNE2000Sample::GetLinkIntegrity()////		Get the link integrity flag//void TNE2000Sample::GetLinkIntegrity(){  	EinsteinNetGetLinkIntegrity(this);	NewtonErr err = noErr;	//Boolean linkIntegrity = NICGetLinkIntegrity();					// Get link status	//fDriverAPI->PostReply(err, 1, linkIntegrity);					// Reply	fDriverAPI->PostReply(err, 1, 1);					// Reply}////	void TNE2000Sample::SetPromiscuous(ULong prom)////		Set promiscuous mode to Rx all packets (prom <> 0: enable)//void TNE2000Sample::SetPromiscuous(ULong prom){  	EinsteinNetSetPromiscuous(this);	NewtonErr err = noErr; //NICSetPromiscuous(prom);						// Set it	fDriverAPI->PostReply(err);										// Reply}////	void TNE2000Sample::GetThroughput()////		Get driver throughput. Not available for NE2000//void TNE2000Sample::GetThroughput(){  	EinsteinNetGetThroughput(this);	fDriverAPI->PostReply(kError_Call_Not_Implemented);				// Reply not implemented error}////	***** Card and NIC routines *****//////	NewtonErr TNE2000Sample::InitCard()////		Initialize card after power on//NewtonErr TNE2000Sample::InitCard(){  	EinsteinNetInitCard(this);	return noErr;	NewtonErr err = noErr;	// Init card interface	fCardSocket->SelectIOInterface();								// Init bus to io configuration	WriteRegB(ToLittleEndianAddr(fCardConfigBaseAddr), fCardConfigNumber);	// Set up card configuration		// Set bus control to the following for debugger to display 8-bit control registers correctly:	// For 16-bit card: set to auto increment addr, assembly 32 (2 16-bit accesses), Auto size with IOIs16 	// For 8-bit card:  set to auto increment addr, assembly 32 (4 8-bit accesses), Auto size with IOIs16 or byte access	fCardSocket->SetControl(kCardAssembly32 | kCareAutoIncAddress /* FIXME: | kCardAutoIOIs16*/ );	// Init NIC		err = NICInit();												// Init for Rx or Tx		return err;}	////	NewtonErr TNE2000Sample::SetCardInfo()////		Set up card info, Ethernet addr and buffer size, and Tx queue//		This can only be called after the NIC is set up, NICInit()//NewtonErr TNE2000Sample::SetCardInfo(){  	EinsteinNetSetCardInfo(this);	return noErr;	NewtonErr err = noErr;	register ULong baseAddr = fNICBaseAddr;							// Get base address	ULong i;	// Get Ethernet addr from card	TEthernetIdBlk ethernetIdBlock;									// Get Ethernet id block	err = NICRemoteDMAXfer((UChar*)&ethernetIdBlock, nil, kNE2KEthernetIdBlockOffset, sizeof(TEthernetIdBlk), kNICCommandRemoteDMARead);	if (err) goto exit;	// Check NIC bus width	if (ethernetIdBlock.fBusWidth[0] == 'W')						// Check 8 or 16-bit mode	{		#if !Do8BitXferOnly			fStatus |= kStatusNIC16Bit;								// Set 16-bit xfer			WriteRegB(baseAddr + kNICDataConfigRegOffset, kDefaultDataConfigValue | kNICDataConfigWordTransfer);		#endif	}	// Check card buffer	ULong bufferSize = (fStatus & kStatusNIC16Bit) ? kNE2KBufferMaxSize : kNE2KBufferMinSize;	bufferSize = NICCheckCardBuffer(bufferSize);					// Check buffer	XREQUIRE_ACTION(bufferSize, exit, err = eLANTERN_DriverHardwareFailure;);		fRxPageStart = (bufferSize / kNICTxBufferRatioDenominator * kNICTxBufferRatioNumerator >> 8) + kNICTxPageStart;									fRxPageStop = (bufferSize >> 8) + kNICTxPageStart;								  #ifdef forDebug	printf("\nNE2K Ethernet id block: ");							// Print out Ethernet id block	for (i = 0; i < sizeof(TEthernetIdBlk); i++)	{		if (i == sizeof(TEthernetIdBlk)/2) printf("\n                        ");		printf("%02X ", ((UChar*)(&ethernetIdBlock))[i]);	}	printf("\nNE2K Card buffer ckecked: '%c' 0x%X bytes (%d KB), DMA pages %02X/%02X/%02X (Tx/Rx %d/%d)\n", 			ethernetIdBlock.fBusWidth[0], bufferSize, bufferSize/1024,			kNICTxPageStart, fRxPageStart, fRxPageStop,			(fRxPageStart - kNICTxPageStart), (fRxPageStop - fRxPageStart));  #endif	ADD_TRACE_EVENT(kNE2000EventBufferSize, ethernetIdBlock.fBusWidth[0], bufferSize);	ADD_TRACE_EVENT(kNE2000EventBufferPages, kNICTxPageStart, (fRxPageStart << 8) | fRxPageStop);	// Set up Tx queue	fTxPacketQueue = new TTxPacketQueue;							// Create a Tx queue	XREQUIRE_ACTION(fTxPacketQueue, exit, err = kError_No_Memory;);  #ifdef forDebug	fTxPacketQueue->fNE2000Sample = this;							// For debugging, Tx queue to access NE2000Sample's fEventTraceCollector  #endif	err = fTxPacketQueue->Init(kNICTxPageStart, fRxPageStart);		// Init	if (err) goto exit;	// Info set. Set up NIC for new change	fStatus |= kStatusCardInfoInited;								// We got card info		// Init DMA reg's again with the new Tx and Rx DMA buffer pages																	// Stop NIC	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0EnableValue);	ULong rxPageStart; rxPageStart = fRxPageStart;	WriteRegB(baseAddr + kNICPageStartRegOffset, rxPageStart);		// Rx page start	WriteRegB(baseAddr + kNICPageStopRegOffset, fRxPageStop);		// Rx page stop	WriteRegB(baseAddr + kNICBoundaryPointerRegOffset, rxPageStart);// Boundary pointer = Page start	fRxNextPacketPage = rxPageStart + 1;							// Next Rx packet page = Page start + 1		// Write Ethernet addr to NIC																	// Select page 1	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage1EnableValue);	WriteRegB(baseAddr + kNICCurrentPageRegOffset, rxPageStart + 1);// Current page = Page start + 1	ULong regBase;	regBase = baseAddr + (kNICPhysicalAddr0RegOffset ^ 3);			// Convert back to big endian address	for (i = 0; i < kPacketAddrSize; i++)	{		UChar addr = ethernetIdBlock.fEthernetAddr[i*2];			// Get ethernet addr (even byte only)		fEthernetAddr[i] = addr;									// Save it		WriteRegB(ToLittleEndianAddr(regBase + i), addr);			// Copy to NIC too	}		// Done																	// Select page 0 and enable NIC	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0EnableValue);exit:	return err;}////	NewtonErr TNE2000Sample::NICInit()////		Initialize NIC, NIC will be placed at page 0, STSRT bit set, loopback mode(no Rx yet) //NewtonErr TNE2000Sample::NICInit(){	NewtonErr err = noErr;	VOLATILE(err);	ADD_TRACE_EVENT(kNE2000EventNICInit, 0, 0);	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address	ULong data;	// Reset NIC	data = ReadRegB(baseAddr + kNE2KResetPortOffset);				// Read and write to reset port	WriteRegB(baseAddr + kNE2KResetPortOffset, 0xff);	NICWaitIdle();													// Double check for idle	// Init configuration reg A & B (NIC can't be accessed between read and write)	data = ReadRegB(baseAddr + kNE2KConfigARegOffset);	WriteRegB(baseAddr + kNE2KConfigARegOffset, kNE2KConfigAFastRdWr);	data = ReadRegB(baseAddr + kNE2KConfigBRegOffset);				// Don't write to kNE2KConfigBGoodLinkDisable and kNE2KConfigBBusError	WriteRegB(baseAddr + kNE2KConfigBRegOffset, kNE2KConfigBPhysLayerAutoDetect);	// Select page 0, disable remote DMA and NIC	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0DisableValue);		// Init data config reg	data = kDefaultDataConfigValue;	if (fStatus & kStatusNIC16Bit)		data |= kNICDataConfigWordTransfer;	WriteRegB(baseAddr + kNICDataConfigRegOffset, data);		// Init remote DMA byte count reg (for remote DMA only)	WriteRegB(baseAddr + kNICRemoteByteCount0RegOffset, 0);	WriteRegB(baseAddr + kNICRemoteByteCount1RegOffset, 0);		// Init Rx config reg	data = kDefaultRxConfigValue;  #ifdef forDebug	if (fDebugControls & kDebugControlSaveErrorPackets)		data |= kNICReceiveConfigSaveErrPackets;	if (fDebugControls & kDebugControlAcceptAllPackets)		data |= kNICReceiveConfigAllPhysicalOK;	if (fDebugControls & kDebugControlRxMonitor)		data |= kNICReceiveConfigMonitor;	if (fDebugControls & kDebugControlNoBroadcastPackets)		data &= ~kNICReceiveConfigBroadcastOK;  #endif	if (fStatus & kStatusRxPromiscuousMode)							// Enable promiscuous mode		data |= kNICReceiveConfigAllPhysicalOK;	WriteRegB(baseAddr + kNICReceiveConfigRegOffset, data);		// Init Tx config reg, set to loop back mode to disable receiver for now	WriteRegB(baseAddr + kNICTransmitConfigRegOffset, kDefaultTxConfigValue | kNICTransConfigLoopbackNIC);		// Init DMA reg's	ULong rxPageStart = fRxPageStart;	WriteRegB(baseAddr + kNICPageStartRegOffset, rxPageStart);		// Rx page start	WriteRegB(baseAddr + kNICPageStopRegOffset, fRxPageStop);		// Rx page stop	WriteRegB(baseAddr + kNICBoundaryPointerRegOffset, rxPageStart);// Boundary pointer = Page start	fRxNextPacketPage = rxPageStart + 1;							// Next Rx packet page = Page start + 1		WriteRegB(baseAddr + kNICTransmitPageStartRegOffset, kNICTxPageStart);	// Tx page start	// Init Interrupt reg's	WriteRegB(baseAddr + kNICInterruptStatusRegOffset, 0xff);		// Clear interrupts	WriteRegB(baseAddr + kNICInterruptMaskRegOffset, 0x00);			// Set interrupt mask	fInterruptMask = 0;  #ifdef forDebug	fInterruptMask = kNICInterruptCounterOverflow;  #endif	// Select page 1	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage1DisableValue);	// Init current DMA reg	WriteRegB(baseAddr + kNICCurrentPageRegOffset, rxPageStart + 1);// Current page = Page start + 1		ULong regBase, i;	// Init physical address reg's	regBase = baseAddr + (kNICPhysicalAddr0RegOffset ^ 3);			// Convert back to big endian address	for (i = 0; i < kPacketAddrSize; i++)		WriteRegB(ToLittleEndianAddr(regBase + i), fEthernetAddr[i]);		// Init multicast address reg's	regBase = baseAddr + (kNICMulticastAddr0RegOffset ^ 3);			// Convert back to big endian address	for (i = 0; i < kNICMulticastAddrSize; i++)		WriteRegB(ToLittleEndianAddr(regBase + i), fMulticastAddrFilterBits[i]);		// Select page 0 and enable NIC for remote DMA	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0EnableValue);	// *** At this point, the receiver is still disabled. NIC is in loopback modeexit:	ADD_TRACE_EVENT(kNE2000EventNICInit, 9, err);	return err;}////	NewtonErr TNE2000Sample::NICStartRx()////		Start Rx //NewtonErr TNE2000Sample::NICStartRx(){	ADD_TRACE_EVENT(kNE2000EventStartRx, 0, 0);	register ULong baseAddr = fNICBaseAddr;	UChar intMask = fInterruptMask |= kDefaultRxInterruptMask;		// Clear and enable interrupts	WriteRegB(baseAddr + kNICInterruptStatusRegOffset, intMask);	WriteRegB(baseAddr + kNICInterruptMaskRegOffset, intMask);	ClearNSetRegBitsB(baseAddr + kNICCommandRegOffset, kNICCommandStop, kNICCommandStart);	// (May be started for remote xfer)	WriteRegB(baseAddr + kNICTransmitConfigRegOffset, kDefaultTxConfigValue | kNICTransConfigLoopbackNormal);//	ADD_TRACE_EVENT(kNE2000EventStartRx, 9, 9);	return noErr;}////	NewtonErr TNE2000Sample::NICStartTx(ULong txPage, ULong size)////		Start Tx from 'txPage' for 'size' bytes//NewtonErr TNE2000Sample::NICStartTx(ULong txPage, ULong size){	ADD_TRACE_EVENT(kNE2000EventStartTx, txPage, size);	if (fStatus & kStatusTxInProgress)								// If Tx in progess	{		ADD_TRACE_EVENT(kNE2000EventStartTx, 8, 8);					// 	Tx in progress	}	else	{		register ULong baseAddr = fNICBaseAddr;						// Start Tx				WriteRegB(baseAddr + kNICTransmitPageStartRegOffset, txPage);// Set Tx page start and byte count			WriteRegB(baseAddr + kNICTransmitByteCount0RegOffset, size & 0xff);		WriteRegB(baseAddr + kNICTransmitByteCount1RegOffset, (size >> 8) & 0xff);		UChar intMask = fInterruptMask |= kDefaultTxInterruptMask;	// Clear and enable interrupts		WriteRegB(baseAddr + kNICInterruptStatusRegOffset, intMask);		WriteRegB(baseAddr + kNICInterruptMaskRegOffset, intMask);			WriteRegB(baseAddr + kNICTransmitConfigRegOffset, kDefaultTxConfigValue | kNICTransConfigLoopbackNormal);																	// Set Start and Tx bits		ClearNSetRegBitsB(baseAddr + kNICCommandRegOffset, kNICCommandStop, kNICCommandStart | kNICCommandTransmitPacket);			fStatus |= kStatusTxInProgress;								// Tx in progress	  #ifdef forDebug		fTxCount++;		if (fDebugControls & kDebugControlPrintProgress)			printf("NE2K Tx packet #%d: page %02X, packetSize %04X(%d)\n", fTxCount, txPage, size, size);	  #endif	}//	ADD_TRACE_EVENT(kNE2000EventStartTx, 9, 9);	return noErr;}////	NewtonErr TNE2000Sample::NICStopRxTx()////		Stop Rx and Tx //NewtonErr TNE2000Sample::NICStopRxTx(){	ADD_TRACE_EVENT(kNE2000EventStopRxTx, 0, 0);	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address	fInterruptMask = 0;  #ifdef forDebug	fInterruptMask = kNICInterruptCounterOverflow;  #endif	WriteRegB(baseAddr + kNICInterruptMaskRegOffset, 0x00);			// Disable all interrupts stop Rx and Tx, and abort remote DMA	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0DisableValue);	fStatus &= ~kStatusTxInProgress;								// Tx not in progress	ADD_TRACE_EVENT(kNE2000EventCommandReg, ReadRegB(baseAddr + kNICCommandRegOffset), kDefaultCmdPage0DisableValue);//	ADD_TRACE_EVENT(kNE2000EventStopRxTx, 9, 9);	return noErr;											}////	NewtonErr TNE2000Sample::NICTxDone()////		Tx done//NewtonErr TNE2000Sample::NICTxDone(){	NewtonErr err = noErr;	ADD_TRACE_EVENT(kNE2000EventTxDone, 0, 0);	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address			  #ifdef forDebug	fTxCollisions = ReadRegB(baseAddr + kNICNumOfCollisionsRegOffset);  #endif	// Stop Tx	UChar intMask = fInterruptMask &= ~kDefaultTxInterruptMask;		// Disable and clear interrupts	WriteRegB(baseAddr + kNICInterruptMaskRegOffset, intMask);	WriteRegB(baseAddr + kNICInterruptStatusRegOffset, kDefaultTxInterruptMask);																	// Disable  Tx	ClearRegBitsB(baseAddr + kNICCommandRegOffset, kNICCommandTransmitPacket);	fStatus &= ~kStatusTxInProgress;								// Tx not in progress	ADD_TRACE_EVENT(kNE2000EventCommandReg, ReadRegB(baseAddr + kNICCommandRegOffset), 0);	err = fTxPacketQueue->RemovePacket();							// Remove packet from queue	if (err) goto exit;	// Tx next packet		TTxPacketInfo* packetInfo = fTxPacketQueue->GetNextPacket();	// Get next packet from queue	if (packetInfo)													// Tx it		err = NICStartTx(packetInfo->fPageStart, packetInfo->fPacketSize);	// Tx next packetexit:	ADD_TRACE_EVENT(kNE2000EventTxDone, 9, 9);	return err;											}////	NewtonErr TNE2000Sample::NICRemoteDMAXfer(UChar* buffer, CBufferList* cBufferList, ULong nicBuffer, ULong size, ULong remoteDMACmd)////		Do remote DMA with 'remoteDMACmd' xfer between system 'buffer' and NIC buffer at 'nicBuffer' for 'size' bytes//NewtonErr TNE2000Sample::NICRemoteDMAXfer(UChar* buffer, CBufferList* cBufferList, ULong nicBuffer, ULong size, ULong remoteDMACmd){	NewtonErr err = noErr;	VOLATILE(err);													// ¥¥ Variable used in exception handling need to be decleared VOLATILE	ADD_TRACE_EVENT(((remoteDMACmd == kNICCommandRemoteDMARead) ? kNE2000EventRemoteDMAXferRead : kNE2000EventRemoteDMAXferWrite), (nicBuffer >> 8), size);	// Set up NIC for remote write	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address	if (fStatus & kStatusNIC16Bit)		size = (size + 3) & 0xfffffffc;								// Make it 32-bit aligned	else		size = (size + 1) & 0xfffffffe;								// Make it 16-bit aligned			WriteRegB(baseAddr + kNICRemoteStartAddr0RegOffset, nicBuffer & 0xff);	// Set remote DMA addr	WriteRegB(baseAddr + kNICRemoteStartAddr1RegOffset, (nicBuffer >> 8) & 0xff);	WriteRegB(baseAddr + kNICRemoteByteCount0RegOffset, size & 0xff);		// Set remote DMA byte count	WriteRegB(baseAddr + kNICRemoteByteCount1RegOffset, (size >> 8) & 0xff);																	// Clear remote DMA complete status	WriteRegB(baseAddr + kNICInterruptStatusRegOffset, kNICInterruptRemoteDMAComplete);																	// Start remote DMA command	ClearNSetRegBitsB(baseAddr + kNICCommandRegOffset, kNICCommandRemoteDMACmdMask, remoteDMACmd);	// Do data xfer (NOTE: Don't use debugger to display data port)	ULong savedControl = fCardSocket->GetControl();					// Save the current setting control	// The PCMCIA ASIC provides controls to read/write 2 16-bit or 4 8-bit data from a data port.	// For a 16-bit operation (a 16-bit data port asserting IOIs16):	//		set card remote DMA to 16-bit xfer	//		set bus to 16-bit, assembly 32 (2 16-bit accesses in a long access), port access, auto size with iois16 on	//		do sw byte swapping (Since hw swapping changes the default PCMCIA bus setting,	//			other tasks and other combo card drivers may access the card incorrectly.)	// For a 8-bit operation (a 8-bit only card or reading Ethernet ID block):	//		set card remote DMA to 8-bit xfer	//		set bus to 8-bit, assembly 32 (4 8-bit accesses in a long access), port access, auto size with iois16 off	//	// To xfer a 1514-byte packet in 16-bit mode:	//		approx 670 us for read, 740 us for a CBufferList write, 460 us for a BufferPtr write	// To xfer a 1514-byte packet in 8-bit mode:	//		approx 850 us for read, 740 us for a CBufferList write, 590 us for a BufferPtr write	ULong control;	if (fStatus & kStatusNIC16Bit)		control = kCardAssembly32 | kCardPortAccess /* FIXME: | kCardAutoIOIs16*/;	else		control = kCardAssembly32 | kCardPortAccess | kCardByteAccess;	ADD_TRACE_EVENT(kNE2000EventRemoteDMAXferData, (cBufferList != 0), 0xffff);	{		fCardSocket->SetControl(control);							// Change the bus controls			register ULong dataPort = baseAddr + kNE2KDataPortOffset;	// Set up data port addr		register ULong xferSize = size;		register ULong swappingMask = 0x00ff00ff;					// Mask for byte-swapping in 16-bit xfer 			if (remoteDMACmd == kNICCommandRemoteDMARead)				// ***ÊDo remote read		{			register ULong* alignedBuffer = (ULong*)buffer;			// Rx buffer from NewPacketPtr is always aligned			if (fStatus & kStatusNIC16Bit)							//	* Do 2 16-bit in 1 long xfer			{				for (register ULong i = 0; i < xferSize; i += 4)				{					register ULong temp0 = ReadReg(dataPort);			//	Swap bytes	11 22 33 44					register ULong temp1 = (temp0 >> 8) & swappingMask;	//				00 11 00 33					temp0 = (temp0 & swappingMask) << 8;				//				22 00 44 00					*alignedBuffer++ = temp0 | temp1;					//				22 11 44 33				}			}			else													//	* Do 4 8-bit in 1 long xfer			{				for (register ULong i = 0; i < xferSize; i += 4)					*alignedBuffer++ = ReadReg(dataPort);			}		}		else														// ***ÊDo remote Write		{			if (cBufferList)										// **ÊIt's a CBufferList 			{				// The packet data in the CBufferList may be less than the min packet size.				// The CBufferList::Get() returns an EOF 0xffffffff, if there's no more data.				// To take advantage of this, the size has been adjusted to min size in				// the SendCBufferList() earlier. So the extra Get() will pad the packet with 0xff.								cBufferList->ResetMark();							// Reset buffer marker					// Because padding to min packet size and also the DMA xfer is adjusted for even byte xfer. 				// A 0xff mask is needed for the odd-byte packet to pick out only 8-bit from the EOF 0xffffffff 				// which returned by the extra Get() of the last xfer.					if (fStatus & kStatusNIC16Bit)						//	* Do 2 16-bit in 1 long write				{					for (register ULong i = 0; i < xferSize; i += 4)					{						register ULong data = cBufferList->Get() << 16;	// 1st byte at bit 23-16						data |= (cBufferList->Get() & 0xff) << 24;		// 2nd byte at bit 31-24						data |= (cBufferList->Get() & 0xff) << 0;		// 3rd byte at bit 07-00						data |= (cBufferList->Get() & 0xff) << 8;		// 4th byte at bit 15-08						WriteReg(dataPort, data);						// Write it					}				}				else												//	* Do 4 8-bit in 1 long write				{					for (register ULong i = 0; i < xferSize; i += 4)					{						register ULong data = cBufferList->Get() << 24;	// 1st byte at bit 31-24						data |= (cBufferList->Get() & 0xff) << 16;		// 2nd byte at bit 23-16						data |= (cBufferList->Get() & 0xff) << 8;		// 3rd byte at bit 15-08						data |= (cBufferList->Get() & 0xff) << 0;		// 4th byte at bit 07-00						WriteReg(dataPort, data);						// Write it					}				}			}			else													// **ÊIt's a UChar* buffer			{				register ULong* alignedBuffer = (ULong*)buffer;		// Tx buffer is always aligned				if (fStatus & kStatusNIC16Bit)						//  * Do 2 16-bit in 1 long xfer				{					for (register ULong i = 0; i < xferSize; i += 4)					{						register ULong temp0 = *alignedBuffer++;			//	Swap bytes	11 22 33 44						register ULong temp1 = (temp0 >> 8) & swappingMask;	//				00 11 00 33						temp0 = (temp0 & swappingMask) << 8;				//				22 00 44 00						WriteReg(dataPort, (temp0 | temp1));				//				22 11 44 33					}				}				else												//	* Do 4 8-bit in 1 long xfer				{					for (register ULong i = 0; i < xferSize; i += 4)						WriteReg(dataPort, *alignedBuffer++);				}			}		}	}	fCardSocket->SetControl(savedControl);							// Restore bus control	ADD_TRACE_EVENT(kNE2000EventRemoteDMAXferData, 0xff, 0xffff);		if (!err)														// Wait for remote DMA done	{		ULong timeout = NICWaitStatus(kNICInterruptRemoteDMAComplete, kWaitForDMADoneTimeOut);		if (timeout)		{			err = eLANTERN_DriverHardwareFailure;			XASSERT(err);		}	}	// Done																	// Reset remote DMA command	ClearNSetRegBitsB(baseAddr + kNICCommandRegOffset, kNICCommandRemoteDMACmdMask, kNICCommandRemoteDMAAbort);	ADD_TRACE_EVENT(((remoteDMACmd == kNICCommandRemoteDMARead) ? kNE2000EventRemoteDMAXferRead : kNE2000EventRemoteDMAXferWrite), 9, err);	return err;}////	NewtonErr TNE2000Sample::NICCheckStatus()////		Check status and dispatch it//NewtonErr TNE2000Sample::NICCheckStatus(){	NewtonErr err = noErr;	register ULong baseAddr = fNICBaseAddr;		register ULong reg = baseAddr + kNICInterruptStatusRegOffset;	register ULong intStatus;										// Interrupt status	ULong intMask = kNICRxInterrupts | kNICTxInterrupts;			// Interrupt mask  #ifdef forDebug	intMask |= kNICInterruptCounterOverflow;	ULong noService = true;											// Check interrupt serviced  #endif	while ((intStatus = ReadRegB(reg) & intMask) != 0)				// Get interrupt status	{	  #ifdef forDebug		fInterruptStatus = intStatus;								// Save interrupt status		fRxStatus = ReadRegB(baseAddr + kNICReceiveStatusRegOffset);		fTxStatus = ReadRegB(baseAddr + kNICTransmitStatusRegOffset);		ADD_TRACE_EVENT(kNE2000EventIntRxTxStatusReg, intStatus, (fRxStatus << 8) | fTxStatus);	  	noService = false;	  #endif		if (intStatus & kNICInterruptOverwriteWarning)				// Rx buffer overflow		{		  #ifdef forDebug			fRxBufferOverflows++;									//	 Increase Rx error count			printf("NE2K Rx buffer overflow #%d\n", fRxBufferOverflows);			ADD_TRACE_EVENT(kNE2000EventRxBufferOverflow, fRxStatus, fRxBufferOverflows);			if (fDebugControls & kDebugControlBreakOnRxTxErrors)				DebugStr("Rx buffer overflow");						//	 Break here if asked		  #endif			err = NICRxBufferOverflow();							//	 Handle Rx buffer overflow		}		else if (intStatus & kNICInterruptReceiveError)				// Rx error		{		  #ifdef forDebug			err = NICGetTallyCounters();							//	 Get tally counters			fRxErrors++;											//	 Increase Rx error count			ADD_TRACE_EVENT(kNE2000EventRxError, fRxStatus, fRxErrors);			printf("NE2K Rx error #%d: 0x%02X\n", fRxErrors, fRxStatus);			if (fDebugControls & kDebugControlBreakOnRxTxErrors)				DebugStr("Rx error");								//	 Break here if asked		  #endif			WriteRegB(reg, kNICInterruptReceiveError);				//	 Clear Rx error		}		else if (intStatus & kNICInterruptPacketReceived)			// Rx ok		{			WriteRegB(reg, kNICInterruptPacketReceived);			//	 Clear Rx ok			ADD_TRACE_EVENT(kNE2000EventRxOk, fRxStatus, 0);			err = NICRxPacketsXfer(true);							//	 Xfer Rx packet data (return if overflow)		}		else if (intStatus & kNICInterruptTransmitError)			// Tx error		{		  #ifdef forDebug			fTxErrors++;											//	 Increase Tx error count			ADD_TRACE_EVENT(kNE2000EventTxError, fTxStatus, fTxErrors);			printf("NE2K Tx error #%d: 0x%02X\n", fTxErrors, fTxStatus);			if (fDebugControls & kDebugControlBreakOnRxTxErrors)				DebugStr("Tx error");								//	 Break here if asked		  #endif			NICTxDone();											//	 Tx done		}		else if (intStatus & kNICInterruptPacketTransmitted)		// Tx ok		{			ADD_TRACE_EVENT(kNE2000EventTxOk, fTxStatus, 0);			NICTxDone();											//	 Tx done		}	  #ifdef forDebug		else if (intStatus & kNICInterruptCounterOverflow)			// Tally counter overflow		{			WriteRegB(reg, kNICInterruptCounterOverflow);			//	 Clear it			err = NICGetTallyCounters();		}	  #endif		else			break;													// Done	}  #ifdef forDebug	if (noService)													// Save interrupt status if no service	{		fInterruptStatus = intStatus;		fRxStatus = ReadRegB(baseAddr + kNICReceiveStatusRegOffset);		fTxStatus = ReadRegB(baseAddr + kNICTransmitStatusRegOffset);		ADD_TRACE_EVENT(kNE2000EventIntRxTxStatusReg, intStatus, (fRxStatus << 8) | fTxStatus);	}  #endif	return err;}////	NewtonErr TNE2000Sample::NICRxPacketsXfer(ULong returnIfOverflow)////		Xfer Rx packet data out//NewtonErr TNE2000Sample::NICRxPacketsXfer(ULong returnIfOverflow){	NewtonErr err = noErr;	ADD_TRACE_EVENT(kNE2000EventRxPacketXfer, 0, 0);	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address	ULong nextPage = fRxNextPacketPage;								// Get next page	ULong currPage, intStatus;	while (nextPage != (currPage = NICGetCurrentRxPage()))			// If more Rx packets, next page != current page	{		ADD_TRACE_EVENT(kNE2000EventRxNxtCur, nextPage, currPage);		if (returnIfOverflow)										// If return when overflow		{															// and is overflow			intStatus = ReadRegB(baseAddr + kNICInterruptStatusRegOffset);			if (intStatus & kNICInterruptOverwriteWarning)			{				ADD_TRACE_EVENT(kNE2000EventRxPacketXfer, 8, intStatus);				break;												// Return			}		}		TNICRxPacketHeader rxHeader;								// Get header		ULong rxPacketPageAddr = nextPage << 8;		err = NICRemoteDMAXfer((UChar*)&rxHeader, nil, rxPacketPageAddr, sizeof(TNICRxPacketHeader), kNICCommandRemoteDMARead);		if (err) goto exit;	  #ifdef forDebug		fRxPacketStatus = rxHeader.fRxStatus;						// Save Rx packet status	  #endif																	// Xfer data to a buffer		ULong packetSize = (rxHeader.fLengthH << 8) | rxHeader.fLengthL;		ULong bufferSize = (packetSize + 3) & 0xfffffffc;			// Request a packet ptr from lantern		Ptr	packetBuffer = fDriverAPI->NewPacketPtr(bufferSize);		if (packetBuffer)											// Read packet from card		{			err = NICRemoteDMAXfer((UChar*)packetBuffer, nil, rxPacketPageAddr + sizeof(TNICRxPacketHeader), packetSize, kNICCommandRemoteDMARead);			if (err) goto exit;		}		else		{			ADD_TRACE_EVENT(kNE2000EventRxNoBufferAvail, 0, 0);		}				ULong startPage = nextPage;		nextPage = rxHeader.fNextPage;								// Set up for next packet		fRxNextPacketPage = nextPage;								// fRxNextPacketPage = next page		ULong boundryPointer = nextPage - 1;						// Boundry pointer = next page - 1		if (boundryPointer < fRxPageStart)							// If boundry pointer < page start			boundryPointer = fRxPageStop - 1;						// Boundry pointer = page stop - 1		WriteRegB(baseAddr + kNICBoundaryPointerRegOffset, boundryPointer);	// Set boundry pointer reg		ADD_TRACE_EVENT(kNE2000EventRxPagesPktNextBnry, startPage, (nextPage << 8) | boundryPointer);	  #ifdef forDebug		fRxCount++;		if (fDebugControls & kDebugControlPrintProgress)		{			ULong crc = (packetBuffer == nil) ? 0 : packetBuffer[packetSize-1] | (packetBuffer[packetSize-2] << 8) |													(packetBuffer[packetSize-3] << 16) | (packetBuffer[packetSize-4] << 24);			printf("NE2K Rx #%d: p/n/b/c/st/int %02X/%02X/%02X/%02X/%02X/%02X, size %04X(%d), CRC %08X, buffer %08X\n",					fRxCount, startPage, nextPage, boundryPointer, currPage, rxHeader.fRxStatus, intStatus,					packetSize, packetSize, crc, packetBuffer);		}		if ((fDebugControls & kDebugControlPrintRxPackets) && packetBuffer)			DumpBuffer((UChar*)packetBuffer, packetSize, startPage << 8);	  #endif			if ((packetSize < kPacketRxMinLength) || (kPacketRxMaxLength < packetSize) ||			(nextPage < fRxPageStart) || (fRxPageStop < nextPage))		{															// Check bad Rx header			err = eLANTERN_DriverHardwareFailure;					// Something is really bad in the Rx buffer		  #ifdef forDebug			fRxBadPageOrSize++;										// Increase bad packet size error count			printf("NE2K Rx packet size error #%d\n", fRxBadPageOrSize);			ADD_TRACE_EVENT(kNE2000EventRxBadPageOrSize, 0, fRxBadPageOrSize);			DebugStr("Bad packet page or size??");		  #endif			break;													// Stop, something is wrong 		}		if (packetBuffer)											// Send it to higher level		{			//	Filtering multicast addresses			//		Some Ethernet card can only turn on and off to receive all Ethernet multicast packets.			//		To improve the performance, the driver should remember the multicast address requests			//		and accept only those packets for the multicast addresses, broadcast address and			//		physical address of the Ethernet card.			//			//		A packet pointer from NewPacketPtr() not returned by RxReady() will be freed next time the NewPacketPtr() is called.			register ULong destiAddr0 = ((ULong*)packetBuffer)[0];			register ULong destiAddr1 = ((ULong*)packetBuffer)[1];																	// Check our physical address			ULong notAccepted = (((ULong*)fEthernetAddr)[0] ^ destiAddr0) |								((((ULong*)fEthernetAddr)[1] ^ destiAddr1) & 0xffff0000);						if (notAccepted)										// Check broadcast address				notAccepted = (destiAddr0 ^ 0xffffffff) | ((destiAddr1 ^ 0xffffffff) & 0xffff0000);			if (notAccepted)										// Check multicast addresses				notAccepted = (fMulticastAddrDataBase->FindMulticastAddr((UChar*)packetBuffer) == nil);						if (!notAccepted)			{				ADD_TRACE_EVENT(kNE2000EventDriverAPIEnter, 0, 0);	// Send it up				fDriverAPI->RxReady(packetBuffer, packetSize - kPacketCRCSize);				ADD_TRACE_EVENT(kNE2000EventDriverAPIExit, 0, 0);			}		}	}  #ifdef forDebug	if ((fDebugControls & kDebugControlPrintProgress) && (nextPage == currPage))		printf("NE2K Rx next == cuur (%02X)\n", nextPage);  #endif				ADD_TRACE_EVENT(kNE2000EventRxNxtCur, nextPage, currPage);exit:	ADD_TRACE_EVENT(kNE2000EventRxPacketXfer, 9, err);	return err;}////	NewtonErr TNE2000Sample::NICRxBufferOverflow()////		Recover from Rx ring buffer overflow //NewtonErr TNE2000Sample::NICRxBufferOverflow(){	NewtonErr err = noErr;//	ADD_TRACE_EVENT(kNE2000EventRxBufferOverflow, 0, 0);	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address	// Stop Tx and remote DMA																	// Was it transmitting, save Tx bit for resend later	ULong resend = ReadRegB(baseAddr + kNICCommandRegOffset) & kNICCommandTransmitPacket;																	// Stop NIC and wait 1.6 ms for Tx/Rx done//	WriteRegB(baseAddr + kNICCommandRegOffset, kNICCommandRemoteDMAAbort);//	ADD_TRACE_EVENT(kNE2000EventCommandReg, ReadRegB(baseAddr + kNICCommandRegOffset), kNICCommandRemoteDMAAbort);	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0DisableValue);	ADD_TRACE_EVENT(kNE2000EventCommandReg, ReadRegB(baseAddr + kNICCommandRegOffset), kDefaultCmdPage0DisableValue);	fStatus &= ~kStatusTxInProgress;								// Tx not in progress	err = NICWaitIdle();											// Wait for Tx/Rx done	if (err) goto exit;	WriteRegB(baseAddr + kNICRemoteByteCount0RegOffset, 0);			// Init remote DMA byte count reg	WriteRegB(baseAddr + kNICRemoteByteCount1RegOffset, 0);		if  (resend &&													// If it was transmitting and it was done		(GetRegBitsB(baseAddr + kNICInterruptStatusRegOffset, kDefaultTxInterruptMask) != 0))			resend = false;											// 	no need for resend																	// Set transmit config reg to loop back mode to disable receiver	WriteRegB(baseAddr + kNICTransmitConfigRegOffset, kDefaultTxConfigValue | kNICTransConfigLoopbackNIC);																	// Set Start to enable NIC	WriteRegB(baseAddr + kNICCommandRegOffset, kDefaultCmdPage0EnableValue);	ADD_TRACE_EVENT(kNE2000EventCommandReg, ReadRegB(baseAddr + kNICCommandRegOffset), kDefaultCmdPage0EnableValue);	// Xfer Rx packets	err = NICRxPacketsXfer(false);									// Xfer Rx packet data (no return if overflow)	if (err) goto exit;	// Clear status and restart Rx/Tx																	// Clear buffer overflow 	WriteRegB(baseAddr + kNICInterruptStatusRegOffset, kNICInterruptOverwriteWarning | kNICInterruptReceiveError);																	// Out of loop back and start Rx again	WriteRegB(baseAddr + kNICTransmitConfigRegOffset, kDefaultTxConfigValue | kNICTransConfigLoopbackNormal);	if (resend)														// Resend if Tx was not done	{																// Tx next packet		TTxPacketInfo* packetInfo = fTxPacketQueue->GetNextPacket();// Get next packet from queue		if (packetInfo)												// Tx it		{			err = NICStartTx(packetInfo->fPageStart, packetInfo->fPacketSize);			if (err) goto exit;		}	}  #ifdef forDebug	printf("NE2K Rx buffer overflow restarted\n");  #endif	exit:	ADD_TRACE_EVENT(kNE2000EventRxBufferOverflow, 9, err);	return err;}////	NewtonErr TNE2000Sample::NICWaitIdle()////		Wait for NIC idle after a reset or STOP //NewtonErr TNE2000Sample::NICWaitIdle(){	ADD_TRACE_EVENT(kNE2000EventWaitForIdle, 0, 0);	Sleep(2 * kMilliseconds);										// Wait 1.6 ms	ADD_TRACE_EVENT(kNE2000EventWaitForStatus, 0, 0);	ULong timeout = NICWaitStatus(kNICInterruptResetStatus, kWaitForIdleTimeOut);	ADD_TRACE_EVENT(kNE2000EventWaitForIdle, 9, timeout);	return timeout ? eLANTERN_DriverHardwareFailure : noErr;}////	NewtonErr TNE2000Sample::NICWaitStatus(ULong reg, ULong mask, ULong timeout)////		Wait for 'mask' bit in interrupt status set or time out 'timeout'//		Return true for timeout or false for ok (Status bit is cleared)//ULong TNE2000Sample::NICWaitStatus(ULong mask, ULong timer){//	ADD_TRACE_EVENT(kNE2000EventWaitForStatus, 0, 0);	register ULong reg = fNICBaseAddr + kNICInterruptStatusRegOffset;	TDelayTimer delayTimer;											// Set up a timer	ULong timeout = false;	delayTimer.ResetTimeOut(timer);									// Wait	while (((ReadRegB(reg) & mask) == 0) && ((timeout = delayTimer.TimedOut()) == false));	XASSERTNOT(timeout);	WriteRegB(reg, mask);											// Clear status//	ADD_TRACE_EVENT(kNE2000EventWaitForStatus, 9, timeout);	return timeout;}////	NewtonErr TNE2000Sample::NICAddDeleteMulticastAddr(UChar* addr, Boolean add)////		Add or delete a multicast address (up to 64 addresses)////			The multicast addr is hashed by the following//			1. Send the 6-byte multicast address through CRC generator//			2. Pick up the highest 6 bits//			3. Use the 6 bits as an index to an array of 64 filter bits (8 bytes)//			4. Set the corresponding bits in the filter bits//			5. Write 8-byte filter bits to NIC//NewtonErr TNE2000Sample::NICAddDeleteMulticastAddr(UChar* addr, Boolean add){	NewtonErr err = noErr;	Boolean updateNIC = false;										// Add or delete the multicast addr in the data base	err = fMulticastAddrDataBase->AddDeleteMulticastAddr(addr, add, &updateNIC);	if (err || (!updateNIC))										// Return if an error or no need to update NIC registers		return err;	// Hash multicast address to a filter bit		ULong crc = AUTODIN_II_CRC(addr, 6);							// Get CRC for the 6-byte multicast addr	ULong index = (crc >> 26) & 0x3f;								// Get highest 6 bits as an index (0-63)	ULong byteNumber = index >> 3;									// Byte number in the multicast addr	ULong bitMask = 1 << (index & 7);								// Bit mask in the selected byte	UChar filterByte = fMulticastAddrFilterBits[byteNumber];		// Get the affective filter byte	if (add)		filterByte |= bitMask;										// Set the corresponding bit to 1	else		filterByte &= ~bitMask;										// Clear the corresponding bit ro 0	fMulticastAddrFilterBits[byteNumber] = filterByte;				// Save it		// Write multicast address to NIC	register ULong baseAddr = fNICBaseAddr;							// Select page 1	UChar savedCmdData = ReadRegB(baseAddr + kNICCommandRegOffset);	WriteRegB(baseAddr + kNICCommandRegOffset, (savedCmdData & (~kNICCommandPageSelectMask)) | kNICCommandPageSelect1);	ULong regBase = baseAddr + (kNICMulticastAddr0RegOffset ^ 3);	// Convert back to big endian address	WriteRegB(ToLittleEndianAddr(regBase + byteNumber), filterByte);// Write out the bytes		WriteRegB(baseAddr + kNICCommandRegOffset, savedCmdData);		// Restore page 0	return err;}////	ULong TNE2000Sample::AUTODIN_II_CRC(UChar* data, ULong size)////		Do the AUTODIN II CRC generation and return a 32-bit CRC//ULong TNE2000Sample::AUTODIN_II_CRC(UChar* data, ULong size){	#define AUTODIN_II_POLYNOMIAL	0x4c11db6   					// AUTODIN II polynomial constant	#define CRC_POLYNOMIAL			0x104c11db7						// CRC polynomial constant	ULong i, crc, cy, bit, poly = AUTODIN_II_POLYNOMIAL;	for (crc = 0xffffffff, i = 0; i < size; i++)	{		for (bit = 0; bit < 8; bit++)		{			cy = (crc >> 31) ^ ((data[i] & (1 << bit)) >> bit);			crc <<= 1;			if (cy)				crc = (crc ^ AUTODIN_II_POLYNOMIAL) | cy;		}	}	return crc;}////	Boolean TNE2000Sample::NICGetLinkIntegrity()////		Get link integrity status//Boolean TNE2000Sample::NICGetLinkIntegrity(){	ULong linkIntegrity = (ReadRegB(fNICBaseAddr + kNE2KConfigBRegOffset) & kNE2KConfigBGoodLink) != 0;	return true;													// ¥¥¥¥ Can't get link back from Tamarack chip}////	NewtonErr TNE2000Sample::NICSetPromiscuous(ULong prom)////		Set promiscuous mode to Rx all packets (prom <> 0: enable)//NewtonErr TNE2000Sample::NICSetPromiscuous(ULong prom){	ULong status = fStatus & (~kStatusRxPromiscuousMode);			// Remember promiscuous mode	fStatus = status | (prom ? kStatusRxPromiscuousMode : 0);																	// Set or clear promiscuous mode	ULong data = kDefaultRxConfigValue | (prom ? kNICReceiveConfigAllPhysicalOK : 0);	WriteRegB(fNICBaseAddr + kNICReceiveConfigRegOffset, data);		return noErr;}////	ULong TNE2000Sample::NICGetCurrentRxPage()////		Get current Rx page  //ULong TNE2000Sample::NICGetCurrentRxPage(){	register ULong baseAddr = fNICBaseAddr;							// Get NIC base address	UChar savedCmdData = ReadRegB(baseAddr + kNICCommandRegOffset);	// Select page 1	WriteRegB(baseAddr + kNICCommandRegOffset, (savedCmdData & (~kNICCommandPageSelectMask)) | kNICCommandPageSelect1);	ULong currentPage = ReadRegB(baseAddr + kNICCurrentPageRegOffset);	// Read current page 	WriteRegB(baseAddr + kNICCommandRegOffset, savedCmdData);		// Restore page 0	return currentPage;}#ifdef forDebug////	NewtonErr TNE2000Sample::NICGetTallyCounters()////		Get tally counters after a MSB set interrupt. Counter are auto cleared //NewtonErr TNE2000Sample::NICGetTallyCounters(){	register ULong baseAddr = fNICBaseAddr;							// Read the counters, auto clear by NIC	fTallyCounterFrameAlignmentErrors += ReadRegB(baseAddr + kNICTallyCounter0RegOffset);	fTallyCounterCRCErrors += ReadRegB(baseAddr + kNICTallyCounter1RegOffset);	fTallyCounterMissedPacketErrors += ReadRegB(baseAddr + kNICTallyCounter2RegOffset);		return noErr;}#endif////	ULong TNE2000Sample::NICCheckCardBuffer(ULong expectedSize)////		Card buffer test and return the size in byte//ULong TNE2000Sample::NICCheckCardBuffer(ULong expectedSize){	UChar buffer[kNICPageSize];	UChar compBuffer[kNICPageSize];	for (ULong pageNum = kNE2KBufferOffset >> 8, size = 0; (size == 0); pageNum++)	// Check page by page	{		// Fill up the card buffer with incremental data starting with the page number of that page		FillBuffer(buffer, kNICPageSize, pageNum);		NICRemoteDMAXfer(buffer, nil, pageNum * kNICPageSize, kNICPageSize, kNICCommandRemoteDMAWrite);		// Compare buffer data (The memory wrap around to Ethernet id block and the compare will fail)				NICRemoteDMAXfer(compBuffer, nil, pageNum * kNICPageSize, kNICPageSize, kNICCommandRemoteDMARead);		for (ULong i = 0; i < kNICPageSize; i++)		{			if (compBuffer[i] != ((pageNum + i) & 0xff))			// Buffer wrapped around			{				size = (pageNum * kNICPageSize) - kNE2KBufferOffset;// Calulate size				XASSERT(size >= expectedSize);						// Diagnostic check				break;												// Done			}		}	}	return size;}////	void TNE2000Sample::FillBuffer(UChar* buffer, ULong size, ULong startValue)////		Fill buffer with incremental data.////			Each 256 bytes starts with the page number.//			So each 256 bytes is unique////				000-1ff		00-ff//				100-1ff		01-00//				200-2ff		02-01//				 .....		 ...//void TNE2000Sample::FillBuffer(UChar* buffer, ULong size, ULong startValue){	for (ULong i = 0, data = startValue; i < size; i++, data++)		buffer[i] = (UChar)((i >> 8) + data);}////	***** TTxPacketQueue *****//////	TTxPacketQueue::TTxPacketQueue()////		TTxPacketQueue constructor//TTxPacketQueue::TTxPacketQueue()									// Constuctor{	fPacketList = nil;}////	TTxPacketQueue::~TTxPacketQueue()////		TTxPacketQueue destructor//TTxPacketQueue::~TTxPacketQueue()									// Destuctor{	delete [] fPacketList;}////	NewtonErr TTxPacketQueue::Init(ULong txPageStart, ULong txPageStop)////		Init Tx queue with 'txPageStart' and 'txPageStop'//NewtonErr TTxPacketQueue::Init(ULong txPageStart, ULong txPageStop)	// Init{	NewtonErr err = noErr;		fTxQueuePages = txPageStop - txPageStart;						// Number of pages in queue	fPacketList = new TTxPacketInfo[fTxQueuePages];					// Create packet list	XREQUIRE_ACTION(fPacketList, exit, err = kError_No_Memory;);	fTxPageStart = txPageStart;										// Set page start	fTxPageStop = txPageStop;										// Set page stop	fFirstPacketIndex = fLastPacketIndex = 0;						// Init index (first == last -> empty)	fTxQueueEmpty = true;											// Queue is empty		DUMP_Tx_QUEUE("init", 0);exit:	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueInit, fTxQueuePages, (txPageStart << 8) | txPageStop);	return err;}////	NewtonErr TTxPacketQueue::AddPacket(ULong packetSize, ULong* packetPageStart)////		Add a packet with size 'packetSize' to Tx queue and return 'packetPageStart' for the package////			1. Find available pages in the Tx buffer//			2. Check to see the Tx packet fit in the end or beginning side of the Tx buffer.//			3. If found, add the Tx info to queue. Otherwise return error.//NewtonErr TTxPacketQueue::AddPacket(ULong packetSize, ULong* packetPageStart)	// Add packet to the end of the queue{	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueAddPacket, 0, packetSize);	NewtonErr err = noErr;		ULong packetPages = (packetSize + (kNICPageSize - 1)) / kNICPageSize;		// Number of pages for the packet	ULong nextPacketPageStart = 0;									// Next packet page start	// Find pages for new packet	if (fTxQueueEmpty)												// If queue is empty	{		nextPacketPageStart = fTxPageStart;							//	next packet page starts form the beginning		fTxQueueEmpty = false;										// 	queue is not empty	}	else															// If not empty	{		long availablePages = 0;									//	find available pages		ULong firstPacketPageStart = fPacketList[fFirstPacketIndex].fPageStart;		ULong lastPacketPageStop = fPacketList[fLastPacketIndex].fPageStop;		if (firstPacketPageStart >= lastPacketPageStop)				//		Tx buffer is wrapped around		{															//		-> check the space between the first and last packets			availablePages = firstPacketPageStart - lastPacketPageStop;			if (availablePages >= packetPages)						//			If packet is smaller than available pages				nextPacketPageStart = lastPacketPageStop;			//				next packet page start = last packet page stop		}		else														//		Tx buffer is not wrapped around		{															//		-> check the spaces at the end and beginning of the buffer			availablePages = fTxPageStop - lastPacketPageStop;			if (availablePages >= packetPages)						//			If fit at the end of the buffer				nextPacketPageStart = lastPacketPageStop;			//				next packet page start = last packet page stop			else			{				availablePages = firstPacketPageStart - fTxPageStart;				if (availablePages >= packetPages)					//			If fit at the beginning of the buffer					nextPacketPageStart = fTxPageStart;				//				next packet page start = Tx buffer page start			}		}		if (nextPacketPageStart != 0)								// Update queue index and state		{			fLastPacketIndex++;										// Increase first index			if (fLastPacketIndex == fTxQueuePages)					// Check end of packet list				fLastPacketIndex = 0;								// Adjust index		}	}	// Save packet info	if (nextPacketPageStart != 0)									// If found some pages	{		TTxPacketInfo* packetInfo = &fPacketList[fLastPacketIndex];	//	set up packet info		packetInfo->fPacketSize = packetSize;			packetInfo->fPageStart = nextPacketPageStart;		packetInfo->fPageStop = nextPacketPageStart + packetPages;	}	else															// No pages found	{		err = eLANTERN_DriverResourceFailure;						//	no more buffer for Tx	  #ifdef forDebug		fNE2000Sample->fTxBufferOverflows++;	  #endif		ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueOverflow, 0, fNE2000Sample->fTxBufferOverflows);	  #ifdef forDebug		printf("NE2K Tx queue overflow #%d\n", fNE2000Sample->fTxBufferOverflows);		if (fNE2000Sample->fDebugControls & kDebugControlBreakOnRxTxErrors)			DebugStr("Tx queue overflow");	  #endif	}		*packetPageStart = nextPacketPageStart;							// Return next packet page start	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueFirstPacket, fFirstPacketIndex, (fPacketList[fFirstPacketIndex].fPageStart << 8) | fPacketList[fFirstPacketIndex].fPageStop);	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueLastPacket, fLastPacketIndex, (fPacketList[fLastPacketIndex].fPageStart << 8) | fPacketList[fLastPacketIndex].fPageStop);	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueAddPacket, 9, nextPacketPageStart);	DUMP_Tx_QUEUE("added", nextPacketPageStart);	return err;}////	NewtonErr TTxPacketQueue::RemovePacket()////		Remove the first (current) package from the Tx queue//NewtonErr TTxPacketQueue::RemovePacket()							// Remove packet from the beginning of the queue{	if (!fTxQueueEmpty)												// If queue is not empty	{		if (fLastPacketIndex == fFirstPacketIndex)					// If no more packet			fTxQueueEmpty = true;									// 	queue is empty		else		{															// Remove first packet from the beginning of the queue			fFirstPacketIndex++;									// Increase first index			if (fFirstPacketIndex == fTxQueuePages)					// Check end of packet list				fFirstPacketIndex = 0;								// Adjust index		}	}	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueFirstPacket, fFirstPacketIndex, (fPacketList[fFirstPacketIndex].fPageStart << 8) | fPacketList[fFirstPacketIndex].fPageStop);	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueLastPacket, fLastPacketIndex, (fPacketList[fLastPacketIndex].fPageStart << 8) | fPacketList[fLastPacketIndex].fPageStop);	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueRemovePacket, 9, fTxQueueEmpty);	DUMP_Tx_QUEUE("removed", fTxQueueEmpty);	return noErr;}////	NewtonErr TTxPacketQueue::GetNextPacket()////		Get the first (current) package from the Tx queue//TTxPacketInfo* TTxPacketQueue::GetNextPacket()						// Get next packet from the beginning of the queue {	TTxPacketInfo* txPacketInfo = (fTxQueueEmpty) ? nil : &fPacketList[fFirstPacketIndex];	  #ifdef forDebug	ULong pageStart = txPacketInfo ? txPacketInfo->fPageStart : 0;	ULong packetSize = txPacketInfo ? txPacketInfo->fPacketSize : 0;	ADD_TRACE_EVENT_TxQ(kNE2000EventTxQueueGetPacket, pageStart, packetSize);	if (fNE2000Sample->fDebugControls & kDebugControlPrintTxQueue) 		printf("NE2K Tx queue: next %02X, %04X(%d)\n", pageStart, packetSize, packetSize);  #endif	return txPacketInfo;}#ifdef forDebug////	***** Debugging code *****//////	void TTxPacketQueue::DumpTxQueueinfo(char* msg, ULong p0)////		Dump Tx queue info for debugging//void TTxPacketQueue::DumpTxQueueinfo(char* msg, ULong p0)			// Dump queue info {	printf("NE2K Tx queue: %s %X(%d) start/stop/pages/empty %02X/%02X/%02X/%02X index %02X/%02X",			msg, p0, p0, fTxPageStart, fTxPageStop, fTxQueuePages, fTxQueueEmpty, fFirstPacketIndex, fLastPacketIndex);	for (ULong i = 0; i < fTxQueuePages; i++)	{		if ((i & 3) == 0) printf("\n");		char ch0 = ' ', ch1 = ' ';		if (i == fFirstPacketIndex) ch0 = 'F';		if (i == fLastPacketIndex) ch1 = 'L';				TTxPacketInfo* packetInfo = &fPacketList[i];		printf("   %02X%c%c %04X %02X %02X", i, ch0, ch1, packetInfo->fPacketSize,				packetInfo->fPageStart, packetInfo->fPageStop); 	}	printf("\n");}////	void TNE2000Sample::DumpBuffer(UChar* buffer, ULong size, ULong startingAddr)////		Dump buffer data//void TNE2000Sample::DumpBuffer(UChar* buffer, ULong size, ULong startingAddr){	for (ULong i = 0; i < ((size+15) / 16); i++)	{		if ((i & 7) == 0)			printf("\n");		printf("%04X.%04X:", startingAddr + i*16, i*16);		for (ULong j = 0; j < 16; j++)		{			if ((j&3) == 0) printf(" ");			printf("%02X ", buffer[j]);			if (j == 7) printf("-");		}		printf("  ");		for (j = 0; j < 16; j++)		{			if ((j&7) == 0) printf(" ");			char ch = buffer[j];			if ((ch < ' ') || (127 < ch))				ch = '.';			printf("%c", ch);		}		printf("\n");		buffer += 16;	}	printf("\n");}#endif////	***** TMulticastAddrDataBase *****//////	TMulticastAddrDataBase::TMulticastAddrDataBase()////		TMulticastAddrDataBase constructor//TMulticastAddrDataBase::TMulticastAddrDataBase(){}////	TMulticastAddrDataBase::~TMulticastAddrDataBase()////		TMulticastAddrDataBase constructor//TMulticastAddrDataBase::~TMulticastAddrDataBase(){	TMulticastAddrEntry* addrEntry;	while ((addrEntry = (TMulticastAddrEntry*)fMulticastAddressList.Last()) != nil)	{		fMulticastAddressList.RemoveLast();							// Remove from the list		delete addrEntry;											// Delete the entry	}}////	TMulticastAddrDataBase::AddDeleteMulticastAddr(UChar* addr, Boolean add, Boolean* updateNIC)////		Add or delete a multicast address//NewtonErr TMulticastAddrDataBase::AddDeleteMulticastAddr(UChar* addr, Boolean add, Boolean* updateNIC){	NewtonErr err = noErr;	*updateNIC = false;	TMulticastAddrEntry* addrEntry = FindMulticastAddr(addr);		// Find the address in the list		if (add)														// Add a multicast address	{		if (addrEntry != nil)										//	if already exist		{			addrEntry->fRequestCount++;								//		increase request count		}		else														//	if not exist		{			addrEntry = new TMulticastAddrEntry;					//		create a new multicast address entry			XREQUIRE_ACTION(addrEntry, exit, err = kError_No_Memory;);						for (ULong i = 0; i < kPacketAddrSize; i++)				//		store the multicast address				addrEntry->fMulticastAddr[i] = addr[i];			addrEntry->fRequestCount = 1;							//		init request count			fMulticastAddressList.InsertLast(addrEntry);			//		insert to multicast address list			*updateNIC = true;										//		update the NIC chip later		}	}	else															// Remove a multicast address	{		if (addrEntry != nil)										//	if already exist		{			if ((--addrEntry->fRequestCount) == 0)					//		decrease request count			{														//		if request count is 0				fMulticastAddressList.Remove(addrEntry);			//			remove it from multicast address list				delete addrEntry;									//			delete the entry				*updateNIC = true;									//			update the NIC chip later			}			else													//	if not				err = eLANTERN_DriverValueRangeError;				//		reprot error		}	}	exit:	return err;}////	TMulticastAddrEntry* TMulticastAddrDataBase::FindMulticastAddr(UChar* addr)////		Find the multicast address entry in the list//TMulticastAddrEntry* TMulticastAddrDataBase::FindMulticastAddr(UChar* addr){	CListIterator iter(&fMulticastAddressList);						// Iterate through the multicast address list	register ULong addr0 = ((ULong*)addr)[0];						// Get address first	register ULong addr1 = ((ULong*)addr)[1];	TMulticastAddrEntry* addrEntry = (TMulticastAddrEntry*)iter.FirstItem();	while (addrEntry)												// Get an entry	{																// Compare address		ULong notMatch = (((ULong*)addrEntry->fMulticastAddr)[0] ^ addr0) |						((((ULong*)addrEntry->fMulticastAddr)[1] ^ addr1) & 0xffff0000);		if (!notMatch)												// If match, break			break;		addrEntry = (TMulticastAddrEntry*)iter.NextItem();			// Next entry	}	return addrEntry;												// Return the entry}#endif